package main

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/spf13/cobra"
)

// Component represents a development tool managed by forge
type Component struct {
	Name        string
	Version     string
	Description string
	Template    string
}

// All components managed by forge
var components = []Component{
	{
		Name:        "go",
		Version:     "go1.25.1",
		Description: "Go toolchain",
		Template:    goTemplate,
	},
	{
		Name:        "jq",
		Version:     "jq-1.7.1",
		Description: "JSON processor",
		Template:    jqTemplate,
	},
	{
		Name:        "snyk",
		Version:     "v1.1295.0",
		Description: "Security vulnerability scanner",
		Template:    snykTemplate,
	},
	{
		Name:        "semgrep",
		Version:     "1.75.0",
		Description: "Static analysis security scanner",
		Template:    semgrepTemplate,
	},
	{
		Name:        "goimports",
		Version:     "v0.29.0",
		Description: "Go import formatter",
		Template:    goimportsTemplate,
	},
	{
		Name:        "python",
		Version:     "3.12.7",
		Description: "Python toolchain",
		Template:    pythonTemplate,
	},
	{
		Name:        "nodejs",
		Version:     "v20.18.0",
		Description: "Node.js runtime",
		Template:    nodejsTemplate,
	},
	{
		Name:        "npm",
		Version:     "10.8.2",
		Description: "npm package manager",
		Template:    npmTemplate,
	},
	{
		Name:        "gh",
		Version:     "v2.65.0",
		Description: "GitHub CLI",
		Template:    ghTemplate,
	},
	{
		Name:        "black",
		Version:     "24.10.0",
		Description: "Python code formatter",
		Template:    blackTemplate,
	},
}

// runSync implements the sync command
func runSync(cmd *cobra.Command, args []string) {
	projectName := args[0]
	sourceFile := args[1]
	outputFile := args[2]

	fmt.Printf("Syncing project: %s\n", projectName)
	fmt.Printf("Source file: %s\n", sourceFile)
	fmt.Printf("Output file: %s\n", outputFile)

	// Read the source Makefile to extract any custom configurations
	sourceContent, err := os.ReadFile(sourceFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading source file %s: %v\n", sourceFile, err)
		os.Exit(1)
	}

	// Generate the forge Makefile
	content := generateMakefile(projectName, string(sourceContent))

	// Ensure output directory exists
	outputDir := filepath.Dir(outputFile)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		fmt.Fprintf(os.Stderr, "Error creating output directory %s: %v\n", outputDir, err)
		os.Exit(1)
	}

	// Write the generated Makefile
	if err := os.WriteFile(outputFile, []byte(content), 0644); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing output file %s: %v\n", outputFile, err)
		os.Exit(1)
	}

	fmt.Printf("Successfully generated %s\n", outputFile)
}

// generateMakefile creates the complete Makefile.forge content
func generateMakefile(projectName, sourceContent string) string {
	var sb strings.Builder

	// Header
	sb.WriteString("# GENERATED BY FORGE - DO NOT EDIT\n\n")
	sb.WriteString(fmt.Sprintf("PROJECT_NAME = %s\n\n", projectName))

	// Core configuration
	sb.WriteString(coreTemplate)

	// Forge configuration
	sb.WriteString(fmt.Sprintf(forgeTemplate, version))

	// Add all component templates
	for _, component := range components {
		sb.WriteString(component.Template)
		sb.WriteString("\n")
	}

	return sb.String()
}
